Linux CLI
=========

1. [Введение](#введение):
   [shell и виртуальные консоли](#shell-и-виртуальные-консоли),
   [SSH](#ssh-secure-shell),
   [SSH-прокси](#ssh-прокси),
   [конвейер и потоки](#конвейер-и-потоки)
1. [Информация о системе](#информация-о-системе):
   [пользовательские лимиты](#пользовательские-лимиты)
1. [ФС](#фс):
   [LVM](#lvm-logical-volume-management),
   [монтирование](#монтирование)
1. [Манипуляции с файлами](#манипуляции-с-файлами):
   [rsync и scp](#rsync-и-scp),
   [архивы](#архивы),
   [права](#права),
   [find](#find)
1. [Манипуляции с текстом](#манипуляции-с-текстом):
   [sed](#sed),
   [vim](#vim)
1. [Сеть](#сеть):
   [interfaces](#настройка-интерфейсов-посредством-etcnetworkinterfaces),
   [systemd-networkd](#настройка-интерфейсов-посредством-systemd-networkd)
1. [Пользователи](#пользователи):
   [sudo и su](#sudo-и-su)
1. [Службы systemd](#службы-systemd):
   [создание службы](#создание-службы),
   [монтирование с systemd](#монтирование-с-systemd)
1. [Переменные окружения](#переменные-окружения)
1. [Криптография](#криптография):
   [пакет ldap-utils](#пакет-ldap-utils)
1. [Deb-пакеты](#deb-пакеты):
   [репозитории](#репозитории),
   [сборка пакетов](#сборка-пакетов),
   [патчинг c quilt](#патчинг-c-quilt)
1. [RPM-пакеты](#rpm-пакеты)
1. [Ядро, модули ядра](#ядро-модули-ядра)
1. [Разработка](#разработка):
   [autotools](#autotools),
   [CMake](#cmake),
   [gdb](#gdb)
1. [Скрипты на Bash](#скрипты-на-bash):
   [функции](#функции),
   [блок if-elif-else-fi](#блок-if-elif-else-fi),
   [циклы](#циклы)
1. [Прочее](#прочее):
   [контрольные суммы](#контрольные-суммы),
   [youtube-dl](#youtube-dl)
   [манипуляции с документами](#манипуляции-с-документами)

# Введение

### Shell и виртуальные консоли

[//]: # (https://www.computernetworkingnotes.com/linux-tutorials/linux-virtual-console-and-terminal-explained.html)
[//]: # (https://habr.com/ru/company/neobit/blog/330764/)

*Shell* — это интерпретатор командной строки.
Вывести текущий интерпретатор:
```
$ echo $SHELL
```

Классификация login/non-login:
1. Login shell — это shell, который запускается при входе пользователя в систему.
1. Non-login shell — это shell, который запускается уже находящимся в системе пользователем.

Классификация interactive/non-interactive:
1. Interactive shell — это shell, в котором можно печатать и прерывать выполнение команд.
1. Non-interactive shell — это shell, который порождается другим процессом.

*Первичная консоль* (boot console) выводит отладочную информацию при загрузке.
*Физический терминал* (физическая консоль, teletype ака TTY) — это использовавшееся в древности устройство для ввода команд.
Состоит из клавиатуры и монитора.
*Виртуальная консоль* — это ПО, имитирующее физический терминал.
У каждой виртуальной консоли есть идентификатор и файл в `/dev`.
`Ctrl`+`Alt`+`F1` включает виртуальную консоль `tty1` и т.д. до `tty6`; `tty7` связан с XServer; `tty8` и т.д. не подают признаков жизни.
Количество активных виртуальных консолей задаётся в `/etc/default/console-setup`, по умолчанию их 6.
При этом `/dev/tty0` = `/dev/console` = текущая консоль, а `/dev/tty` — это консоль, в которой стартовал процесс.

*Псевдо-терминал* (pseudo-terminal, PTY) — это пара виртуальных устройств, master (PTM) и slave (PTS).
Используется как часть окружения для работы с shell.
Псевдо-терминалы создаются для каждого SSH-соединения, для каждой вкладки эмулятора терминала (например, GNOME Terminal или MATE Terminal).
PTM создаётся при открытии `/dev/ptmx`, PTS живут в `/dev/pts`.
Пример:
```
$ tty
/dev/pts/16
$ echo ololo > /dev/pts/16
ololo
```

Некоторые сочетания клавиш:
- очистить экран терминала: `Ctrl`+`L`;
- перейти в начало строки: `Ctrl`+`A`;
- перейти в конец строки: `Ctrl`+`E`;
- удалить слово перед курсором: `Alt`+`Backspace`;
- удалить слово после курсора: `Alt`+`D`;
- если ввести какие-то символы и дважды жмакнуть `Tab`, то выводится список команд, начинающихся с этих символов.

### SSH (Secure Shell)

Сгенерировать ключи:
```
$ ssh-keygen
```
Теперь публичный ключик в `~/.ssh/id_rsa.pub`, приватный — в `~/.ssh/id_rsa`.

Настроить вход на сервер без пароля (ключи должны быть сгенерированы):
```
$ ssh-copy-id ⟨user⟩@⟨host⟩
```
Это добавит новый публичный ключ в файл `~/.ssh/authorized_keys` на сервере.
Если всё равно просит пароль, то на сервере смотрим права `authorized_keys` и его родительских папок (должно быть `600`).

Пробросить порт по SSH:
```
$ ssh -f -N -L ⟨localhost port⟩:⟨target host⟩:⟨target port⟩ ⟨user⟩@⟨public server⟩
```

Удалить хост из файла `known_hosts`:
```
$ ssh-keygen -f ~/.ssh/known_hosts -R ⟨host⟩
```

### SSH-прокси

Дано:
- у нас проброшены ключи к `public-server`;
- `local-server` находится в одной локалке с `public-server`, из вне не доступен.

Задача: подключаться к `local-server` как обычно, т.е.
```
$ ssh ⟨local server user⟩@local-server
```

Решение. В `~/.ssh/config` добавить:
```
Host public-server
    User ⟨public server user⟩
    ForwardAgent yes
    HostName ⟨public server ip⟩
    Port ⟨port⟩

Host local-server
    User ⟨local server user⟩
    HostName ⟨local server ip⟩
    ProxyJump public-server
```

### Конвейер и потоки

Конвейер (pipe) перенаправляет вывод (stdout) 1-й команды на вход (stdin) 2-й команды:
```
$ ⟨command 1⟩ | ⟨command 2⟩
```
Примечания:
1. Все команды в конвейере выполняются параллельно, каждая в своем процессе.
1. Попытка чтения из пустого буфера блокирует процесс, равно как и попытка записи в заполненный буфер.
1. Вывод ошибок (stderr) не перенаправляется.
1. Код завершения конвейера — это код завершения последней команды.
   Это можно изменить с
   ```
   $ set -o pipefail
   ```

`>` перезаписывает файл, а `>>` добавляет содержимое в конец файла.

Интересные «устройства»:
- `/dev/stdin` — стандартный ввод (файловый дескриптор 0);
- `/dev/stdout` — стандартный вывод (файловый дескриптор 1);
- `/dev/stderr` — стандартный вывод ошибок (файловый дескриптор 2);
- `/dev/fd/⟨file descriptor⟩` — заданный файловый дескриптор;
- `/dev/null` — сюда можно скидывать ненужное.

Пример:
```
$ echo 'this is stdout' > /dev/fd/1
this is stdout
```

Писать stdout и stderr в разные файлы:
```
$ ⟨command⟩ 1> capture.log 2> error.log
```

Писать stdout и stderr в один файл:
```
$ ⟨command⟩ > capture.log 2>&1
```

# Информация о системе

Вывести информацию по железу:
```
# dmidecode
```
Если нужна только мать, то добавляем `-t 2`, если память — то `-t 17`.

Также есть:
- `lscpu` и `lsmem` (пакет `util-linux`);
- `lspci` (пакет `pciutils`);
- `lsusb` (пакет `usbutils`);
- файлы `/proc/cpuinfo` и `/proc/meminfo`.

Вывести температуру CPU (требуется пакет `lm-sensors`):
```
$ sensors
```

Вывести дерево процессов:
```
$ ps -aux --forest
```

Запустить процесс, для которого в роли `/` будет выступать указанный каталог:
```
$ chroot ⟨root dir⟩ ⟨command⟩
```

Вывести системную переменную:
```
$ getconf ⟨var⟩
```
Некоторые переменные:
- `PAGE_SIZE` — это объём страницы памяти в байтах;
- `LONG_BIT`, `INT_MAX`, `INT_MIN` и т.д.

Найти бинарь, службу или иной системный файл (требуется пакет `mlocate`):
1. Один раз:
   ```
   # updatedb
   ```
1. ```
   $ locate ⟨file⟩
   ```

Вывести load average для 1, 5 и 15 минут (2 варианта):
```
$ cat /proc/loadavg
$ uptime
```

Вывести инфу по пространствам имён Linux:
```
# lsns
```

### Пользовательские лимиты

Вывести все лимиты текущего пользователя:
```
$ ulimit -a
```
Чтобы вывести конкретный лимит используем нужный флаг.

Некоторые параметры:
1. `nofile` (флаг `-n`) — максимальное количество открытых файлов.
1. `nproc` (флаг `-u`) — максимальное количество процессов.
1. `stack` (флаг `-s`) — максимальный размер стека в Кб.
1. `fsize` (флаг `-f`) — максимальный размер файла в Кб.
1. `core` (флаг `-c`) — максимальный размер core-файла в Кб.

Для перманентного изменения параметра надо внести его в `/etc/security/limits.conf`.
См. также `man limits.conf`.

# ФС

Initrd (initial RAM disk) — это временная ФС, используемая ядром Linux при начальной загрузке.
Initrd обычно используется для начальной инициализации перед монтированием настоящих ФС.

GPT (GUID Partition Table) — это формат размещения таблиц разделов на диске.
В отличие от DOS поддерживает объем более 2 Тб.

Вывести свободное место на дисках:
```
$ df -hT
```
Примечания: `-h` — это человекочитаемый формат, `-T` — это показывать тип ФС.

Вывести статистику по inode:
```
$ df -i
```

Узнать размер папки:
```
$ du -sh ⟨directory⟩
```

Вывести диски:
```
$ lsblk
```

Вывести инфу по диску (указывать диск, например, `/dev/sdc`):
```
# hdparm -i ⟨disk device⟩
```

Выполнить readonly проверку на бэдблоки (указывать раздел, например, `/dev/sdc1`):
```
# badblocks ⟨device⟩
```

Получить UUID всех разделов:
```
$ ls -l /dev/disk/by-uuid
```

Проверить диск на битые сектора (указывать раздел, например, `/dev/sdc1`):
```
# badblocks -n ⟨device⟩
```

Отформатировать диск (указывать раздел, например, `/dev/sdc1`):
```
# mkfs --type=⟨type⟩ ⟨device⟩
```
Примечания:
1. Примеры типов: `ext4`, `vfat`.
1. Раздел не должен быть смонтирован.

Записать загрузочный USB (указывать диск, например, `/dev/sdb`):
```
# dd bs=4M if=⟨iso file⟩ of=⟨device⟩ conv=fdatasync
```

Начать работу с `parted` в интерактивном режиме (указывать диск, например, `/dev/sdc`):
```
# parted ⟨disk device⟩
```
Примечания:
1. `mklabel GPT` — выпилить все данные на диске, создать таблицу разделов в формате GPT.
1. `mkpart ⟨label⟩ ext4 2048s 100%` — создать раздел с ext4 на весь диск.
1. `p` ака `print` — вывести инфу по выбранному диску.
1. `q` ака `quit` — выйти.
1. `fdisk` пока умеет только в таблицу разделов DOS.
1. Не забываем отформатировать новые разделы.

Чтобы увеличить размер ФС, надо удалить раздел и пересоздать его с новым размером:
```
# fdisk /dev/vda
p
d
n
p
# resize2fs /dev/vda1
```
При пересоздании раздела надо указывать тот же начальный сектор, что был изначально.

Выполнить команду, отключив `fsync()`:
```
$ eatmydata ⟨command⟩
```

Найти процессы, использующие файл или папку:
```
$ lsof | grep ⟨file or directory⟩
```
Примечания:
1. `-p` позволяет задать нужный PID или сразу несколько через запятую.
Можно исключать ненужные при помощи `^`, например, `^1,^2,^3`.
1. `-u` позволяет задать нужного пользователя или сразу несколько через запятую.
Можно исключать ненужных при помощи `^`, например, `^root,^georgiy`.

Вывести список процессов, которые используют файлы:
```
$ lslocks
```
Примечания:
1. `-p` ака `--pid` позволяет задать нужный процесс.
1. Если процесс заблокирован из-за того, что файл уже используется, то в колонке `MODE` будет `*`.

### Монтирование

Монтировать диск (точка монтирования должна существовать):
```
# mount -t ⟨type⟩ -o ⟨options⟩ ⟨device⟩ ⟨mount point⟩
```
Монтировать ISO-файл:
```
# mount -o loop ⟨iso file⟩ ⟨mount point⟩
```

Чтобы диск монтировался автоматом, надо добавить соответствующую запись в `/etc/fstab`:
```
⟨device⟩ ⟨mount point⟩ ⟨type⟩ ⟨options⟩ ⟨dump⟩ ⟨pass⟩
```
Пример:
```
/dev/vdb1 /data ext4 rw 0 1
```
Примечание: после изменения `/etc/fstab` можно, не перезагружая ЭВМ, сделать:
```
# mount ⟨mount point⟩
```

Создать раздел на tmpfs:
```
# mount -t tmpfs -o rw,size=2G tmpfs ⟨mount point⟩
```
Через `/etc/fstab`:
```
tmpfs ⟨mount point⟩ tmpfs rw,size=2G 0 0
```

Монтировать папку, находящуюся на другой ЭВМ, по SSH:
```
$ sshfs ⟨user⟩@⟨host⟩:⟨directory⟩ ⟨mount point⟩
```

### LVM (logical volume management)

Warning: если сдохнет один из HDD, управляемых LVM, то можно потерять все данные.

Вывести инфу по группам томов:
```
# vgdisplay
```

Вывести инфу по томам:
```
# lvdisplay
```

Создать группу томов:
```
# vgcreate -c n ⟨group name⟩ ⟨partion device 1⟩ ... ⟨partion device N⟩
```
Примечания:
1. Есть флаг `--yes`.

Создать том, занимающий 100% объёма своей группы:
```
# lvcreate -l 100%VG -n ⟨volume name⟩ ⟨group name⟩
```
Примечания:
1. `-l` ака `--extents` также позволяет указать % от свободного места, например, `-l 100%FREE`.
1. `-L` ака `--size` позволяет указать точный размер, например, `-L 10g`.
1. Теперь надо отформатировать `/dev/⟨group name⟩/⟨volume name⟩` и можно монтировать.

# Манипуляции с файлами

Эти 2 команды аналогичны:
```
$ cp /home/sample.txt{,-old}
$ cp /home/sample.txt /home/sample.txt-old
```

Пакет `rename` для пакетного переименования файлов:
```
$ rename 's/⟨было⟩/⟨стало⟩/' *.txt
```

Создать символьную ссылку:
````
$ ln -s ⟨путь к источнику⟩ ⟨путь к ссылке⟩
````
Здесь `-s` — это символьная ссылка (по умолчанию — жесткая ссылка), `-f` разрешает удаление существующих файлов.

Получить из пути имя файла/папки:
```
$ basename ⟨path⟩
```

Получить из пути путь родительской папки:
```
$ dirname ⟨path⟩
```

Удалить файл с многократной перезаписью случайными данными:
```
$ shred -u -z -n 40 ⟨file 1⟩ ⟨file 2⟩ ...
```
Примечания:
1. `-n` ака `--iterations` позволяет задать количество проходов.
1. `-z` ака `--zero` указывает выполнить финальный проход с заполнением нулями.
1. `-u` указывает удалить файл в конце.

### rsync и scp

Копировать с `rsync`:
```
$ rsync ⟨source⟩ ⟨target directory⟩
```
Примечания:
1. Можно качать по SSH — `⟨user⟩@⟨host⟩:⟨path⟩`.
   При этом `rsync` должен быть установлен и на удалённой машине.
1. Если надо копировать содержимое каталога, то добавляем `/` в конце пути.
   Если надо копировать сам каталог, то не добавляем.
1. `-r` ака `--recursive` — рекурсивно копировать папку.
1. `-l` ака `--links` — копировать символьные ссылки как символьные ссылки.
1. `-e` ака `--rsh` позволяет задать shell.
   Например, задаём нестандартный порт: `--rsh='ssh -p 222'`.
1. `--exclude` позволяет игнорировать ненужные файлы, причём аргументов `--exclude` может быть несколько.
   Пример: `--exclude=*.pdf`.

Копировать с `scp`:
```
$ scp ⟨source⟩ ⟨target directory⟩
```
Примечания:
1. Можно качать по SSH — `⟨user⟩@⟨host⟩:⟨path⟩`.
1. `-r`  — рекурсивно копировать папку.
1. Если надо указать порт, то используем `-P`.
1. `scp` не умеет нормально выкачивать символьные ссылки.

### Архивы

Распаковать `tar.gz`:
```
$ tar -xf ⟨tar.gz file⟩
```
Вынуть один файл из `tar.gz`:
```
$ tar -zxf ⟨tar.gz file⟩ ⟨file to extract⟩
```
Примечание: `--directory` ака `-C` задаёт каталог для записи.

Вывести список файлов, запакованных в `tar.gz`:
```
$ tar -ztf ⟨tar.gz file⟩
```

Запаковать файл или каталог в `tar.gz`:
```
$ tar -zcf ⟨new tar.gz file⟩ ⟨file or directory⟩
```
Примечания:
1. Можно указать сразу много файлов и каталогов.
1. `tar` нормально пакует символьные ссылки.

Запаковать всё содержимое каталога, но не класть в архив сам родительский каталог:
```
$ cd ⟨target directory⟩
$ tar -zcvf ⟨new tar.gz file⟩ .
```

Запаковать и отправить по SSH без создания файла на локальной ЭВМ:
```
$ tar -zcvf - --one-file-system ⟨file or directory⟩ | ssh ⟨login⟩@⟨host⟩ "cat > ⟨new tar.gz file⟩"
```

Распаковать `zip` (2 способа):
```
$ unzip ⟨zip file⟩
$ 7z x ⟨zip file⟩
```

Запаковать папку в `zip`:
```
$ zip -r ⟨zip file⟩ ⟨directory⟩
```
Можно указывать сразу много файлов и папок.
Для файлов `-r` не нужен.

Распаковать `rar`:
```
$ unrar e ⟨rar file⟩
```

Запаковать файл или папку в `rar`:
```
$ rar a ⟨new rar file⟩ ⟨file or directory⟩
```
Можно указать сразу много файлов и папок.
Чтобы поставить пароль на архив используем `-p`.

Распаковать `xz` (нужен пакет `xz-utils`):
```
$ unxz ⟨xz file⟩
```

### Права

| Обозначение | Права |
|:-----------:|:-----:|
| 0           | ---   |
| 1           | --x   |
| 2           | -w-   |
| 3           | -wx   |
| 4           | r--   |
| 5           | r-x   |
| 6           | rw-   |
| 7           | rwx   |

`1777` (отображается как `drwxrwxrwt`) — это спец. права: всем всё можно, но удалять может лишь тот кто создал.

Изменить права на файл или папку:
```
$ chmod ⟨permissions⟩ ⟨file or directory⟩
```
Здесь `permissions` — это права владельца файла, группы файла и всех остальных, например, `664`.
Для рекурсивной обработки подкаталогов используем `-R` или `--recursive`.

Сменить владельца для файла или папки:
```
$ chown ⟨user⟩ ⟨file or directory⟩
```
Сменить владельца и группу для файла или папки:
```
$ chown ⟨user⟩:⟨group⟩ ⟨file or directory⟩
```
`-R` ака `--recursive` — рекурсивно обработать содержимое папки.

Сменить группу для файла или папки:
```
$ chgrp ⟨group⟩ ⟨file or directory⟩
```
`-R` ака `--recursive` — рекурсивно обработать содержимое папки.

Запретить изменение:
```
# chattr +i ⟨file or directory⟩
```

### find

Поиск больших логов:
```
$ find /var/www -type f -name 'access.log*' -size +100M
```

Поиск всех файлов в каталоге /etc/, измененных за последние сутки:
```
$ find /etc/ -type f -mtime -1
```

Подсчитаем суммарный объём логов:
```
$ find /var/www/ -type f -name 'access.log*' -exec du -k {} \; | awk '{s+=$1}END{print s}'
```

# Манипуляции с текстом

Работа с `wc`:
- `wc -l` выдаст количество строк;
- `wc -w` выдаст количество слов;
- `wc -m` выдаст количество символов.

Например, вывести количество строк в текстовом файле:
```
$ cat ⟨file⟩ | wc -l
```

Сравнение папок при помощи пакета `diffoscope`:
```
$ diffoscope --html=log.html --exclude-directory-metadata=yes --max-page-size=15000000 --max-page-diff-block-lines=5000 --no-default-limits ⟨path 1⟩ ⟨path 2⟩
```
`--exclude=⟨pattern⟩` позволяет игнорировать ненужные файлы, причём аргументов `--exclude` может быть несколько.

Проверить наличие строки в файле:
```
$ grep --quiet ⟨pattern⟩ ⟨path⟩
```
Если есть — вернёт `0`, нет — вернёт `1`.

Примечания к `grep`:
1. Оператор ИЛИ в шаблоне: `samba\|smbd`.
1. Выводить также N строк перед найденной строкой: `-B ⟨N⟩`.
1. Выводить также N строк после найденной строки: `-A ⟨N⟩`.

XSLT-преобразование:
```
$ xalan -xsl ⟨xsl-файл⟩ -in ⟨входной xml-файл⟩ -out ⟨output file⟩
```
`xsltproc` — это глючная дрянь, не работают ни `xalan:indent-amount` ни `saxon:indent-spaces`.

Преобразовать файл в HEX и вывести в stdout:
```
$ xxd ⟨input file⟩
```

Преобразовать обратно из HEX:
```
$ xxd -r < ⟨input file with HEX⟩ > ⟨output file⟩
```

### sed

Заменить в файле одну строку на другую:
```
$ sed -i 's/⟨before⟩/⟨after⟩/g' ⟨file⟩
```
Избавиться от `\r`:
```
$ sed -i 's/\r//g' ⟨file⟩
```
Добавить новую строку в самое начало файла:
```
$ sed -i '1s/^/⟨new line⟩\n/' ⟨file⟩
```
Добавить префикс к первым 3 строкам файла:
```
$ sed -i '1,3s/^/⟨some prefix⟩/' ⟨file⟩
```
Удалить первые 3 строки файла:
```
$ sed -i '1,3d' ⟨file⟩
```

При помощи `;` можно применить несколько шаблонов за раз:
```
$ echo 'abcd' | sed 's/ab/xy/;s/cd/ab/;s/xy/cd/'
cdab
```

Примечания по `sed`:
1. Если не указать файл, то будет читать из stdin.
   `-i` ака `--in-place` повелевает перезаписать файл (по умолчанию пишет в stdout).
1. Без флажка `g` будет заменять лишь 1 раз в каждой строке.

### vim

1. `:w` — сохранить.
1. `:q` — выйти из `vim`.
1. `:wq` — выйти из `vim` с сохранением.
1. `:q!` — выйти из `vim` без сохранения.
1. `:set number` ака `:set nu` — отображать номера строк.
1. `:set nonumber` ака `:set nu!` — не отображать номера строк.
1. `i` — войти в режим вставки.
1. Escape — выйти из режима вставки.
1. `dd` — удалить строку.
1. `/⟨search term⟩` — искать.
   `n` — следующий, `N` — предыдущий.
1. `u` ака `:u` ака `:undo` — отмена.

# Сеть

Вывести открытые локальные порты (нужен пакет `net-tools`):
```
$ netstat -tulpn
```
Чтобы показывало процессы, нужны права root.

Вывести количество соединений (нужен пакет `net-tools`):
```
$ netstat -an | wc -l
```

Убить процесс, висящий на заданном порте:
```
$ fuser -k ⟨port⟩/tcp
```

Вевести список ЭВМ в заданной сети:
```
$ nmap -sP 192.168.50.0/24
```

Проверить открыт ли конкретный порт на конкретной ЭВМ:
```
$ nmap ⟨host⟩ -p ⟨port⟩
```

Добавить/удалить маршрут:
```
# route add -net 10.1.1.0/24 gw 10.10.0.1
# route del -net 10.1.1.0/24 gw 10.10.0.1
```

Отправить POST-запрос:
```
$ curl -d "⟨data⟩" -X POST ⟨url⟩
```

Вывести правила брандмауэра netfilter:
```
# iptables --list
```
Разрешить весь исходящий трафик:
```
# iptables -P OUTPUT ACCEPT
```

Записать трафик tcpdump'ом для wireshark:
```
# tcpdump -i ⟨interface⟩ -s 65535 -w ⟨file⟩
```
Отлавливать обмен пакетами с заданным узлом:
```
# tcpdump host ⟨ip⟩
```

`traceroute` определяет маршрут следования данных в сетях TCP/IP:
```
$ traceroute ⟨host⟩
```
Для определения промежуточных маршрутизаторов `traceroute` шлёт целевому узлу пакеты (по умолчанию UDP), с каждым шагом увеличивая значение поля TTL на 1.
1-й маршрутизатор получает пакет с TTL = 1 и сообщает об ошибке.
Процесс повторяется до тех пор, пока пакет не достигнет целевого узла.

Отключить интерфейс:
```
# ifconfig ⟨interface⟩ down
```

Вывести информацию об интерфейсе (нужен пакет `ethtool`):
```
# ethtool ⟨interface⟩
```
Удобно смотреть воткнут ли кабель в разъём.

Вывести все сетевые устройства и их состояние с т.з. NetworkManager:
```
$ nmcli d
```

### Настройка интерфейсов посредством /etc/network/interfaces

Пример интерфейса с DHCP:
```
auto eth0
iface eth0 inet dhcp
```

Пример интерфейса со статическим адресом:
```
auto eth0
iface eth0 inet static
    address 10.1.12.21
    netmask 255.255.255.0
    gateway 10.1.0.1
```

Если не задать `netmask`, то система не выдаст ошибку, а попробует подобрать маску самостоятельно.
Но делать так НЕ надо, надо задавать.

### Настройка интерфейсов посредством systemd-networkd

Правило представляет собой файл с расширением `.network` или `.link`, лежащий в `/etc/systemd/network`.
Пример: `10-persistent-net.link`.

Задать название интерфейса (требуется расширение `.link`):
```
[Match]
MACAddress=⟨mac⟩

[Link]
Name=⟨name⟩
```
Примечания:
1. Если уж назначать имена, то всем, иначе возможны глюки с появлением интерфейсов типа `rename5`.
1. Systemd написан через жопу и может просто не функционировать как описано в документации.
   Если от проблем с `rename5` не удаётся избавиться, то см. [баг 1390](https://github.com/systemd/systemd/issues/1390).

Пример интерфейса с DHCP (тут и далее требуется расширение `.network`):
```
[Match]
Name=⟨interface⟩

[Network]
DHCP=yes
```

Пример интерфейса со статическим адресом:
```
[Match]
Name=⟨interface⟩

[Network]
Address=⟨IP⟩/⟨mask⟩
Gateway=⟨gateway⟩
DNS=⟨DNS server⟩
```

Просим `systemd-networkd` не трогать интерфейс (хотим настраивать посредством `/etc/network/interfaces`):
```
[Match]
Name=⟨interface⟩

[Link]
Unmanaged=yes
```

А ещё можно использовать `*`, например, `Name=en*`.

### DNS

Используемые DNS-сервера прописаны в `/etc/resolv.conf`.

Получить DNS-записи для доменного имени (нужен пакет `dnsutils`):
```
$ dig ⟨domain name⟩
```

# Пользователи

Создать пользователя и задать ему пароль:
```
# useradd --create-home ⟨user⟩
# passwd ⟨user⟩
```

Вывести группы, в которых состоит пользователь:
```
$ groups ⟨user⟩
```
Если пользователь не указан, то свои группы.

Добавить пользователя в группу:
```
# usermod -aG ⟨group⟩ ⟨user⟩
```
Чтобы изменения вступили в силу, пользователю надо перелогиниться.

Вывести всех залогиненых пользователей:
```
$ who
```

### sudo и su

Стать другим пользователем:
```
su ⟨user⟩
```
При этом потребуется ввести пароль этого пользователя.
Флаг `-p` позволяет оставить свои переменные окружения.

Выполнить команду с правами суперпользователя:
```
sudo ⟨command⟩
```
При этом возможно потребуется ввести собственный пароль.
Флаг `-E` ака `--preserve-env` позволяет оставить свои переменные окружения.

Право использовать `sudo` выдаётся через `/etc/sudoers`:
- разрешить использовать sudo, спрашивать пароль:
  ```
  ⟨user⟩ ALL=(ALL:ALL) ALL
  ```
- разрешить использовать sudo, не спрашивать пароль:
  ```
  ⟨user⟩ ALL=(ALL) NOPASSWD:ALL
  ```

# Службы systemd

Где лежат конфиги сервисов:
- `/usr/lib/systemd/user`;
- `/run/systemd/system`;
- `/etc/systemd/system`.

Перезагрузить конфиги сервисов:
```
# systemctl daemon-reload
```

Получить статистику запуска сервисов:
```
$ systemd-analyze plot > stat.svg
```

### Создание службы

Типы служб:
1. simple — главный процесс и является службой.
1. forking — процесс порождает дочерний процесс и выходит.
   Systemd считает службу запущенной, хоть процесс и завершился.
1. oneshot — процесс будет короткоживущим.
   Systemd ждёт его завершения прежде чем запускать зависимые от него службы.
1. notify — служба выпустит оповещение, когда она будет готова.
   Systemd ждёт оповещения прежде чем запускать зависимые от неё службы.
1. idle — Systemd отложит запуск процесса до момента выполнения всех остальных задач, в остальном аналог simple.
1. dbus — служба считается запущенной, когда её имя появится в системной шине DBus.

Минимальный пример service-файла:
```
[Unit]
Description=⟨description⟩

[Service]
Type=simple
ExecStart=⟨command⟩

[Install]
WantedBy=multi-user.target
```

Примечания по секции `Unit`:
1. `Before` и `After` — нужно запускать до/после какого-либо сервиса.
1. `Requires` — зависимость.
   Если при старте происходит взаимодействие с другим сервисом, то его надо прописать и в `Requires` и в `After`.
   Если задан лишь `Requires`, то оба будут запущены одновременно.
1. `BindsTo` — то же что и `Requires` + наш сервис будет остановлен при остановке зависимости.
1. `Wants` — слабая версия `Requires`.
   Наш сервис будет выполняться, даже если systemd не сумеет запустить эту зависимость.
1. `Conflicts` — какой-либо сервис, одновременная работа с которым невозможна.
1. Любой из параметров `Before`, `After`, `Requires`, `BindsTo`, `Wants`, `Conflicts` может встречаться по несколько раз.
1. Можно задать условия запуска: `AssertPathExists`, `AssertPathIsReadWrite`, `AssertDirectoryNotEmpty`, `AssertFirstBoot` и т.д.

Примечания по секции `Service`:
1. `ExecStart`, `ExecReload`, `ExecRestart`, `ExecStop` — команды для запуска, релоада, перезапуска и остановки службы.
1. `ExecStartPre` и `ExecStartPost` — доп. команды, выполняемые до и после `ExecStart`, например, чтобы создать папку под pid-файл в `/var/run`.
   При этом `ExecStartPost` является частью процедуры запуска; пока он не отработает зависимые службы не запускаются.
1. `ExecStopPost` — доп. команда, выполняемая после остановки службы.
1. В `ExecStart` и ко надо использовать абсолютные пути, например, `/bin/mountpoint`.
1. `WorkingDirectory` — рабочая папка.
1. `EnvironmentFile` — путь к файлу с переменными окружения (обычно в `/etc/default`).
1. `TimeoutStartSec` — таймаут на старт службы, `TimeoutStopSec` — таймаут на остановку службы, `TimeoutSec` — единое значение для обоих таймаутов.

Примечания по секции `Install`:
1. Если секции нет, то нельзя выполнить `systemctl enable`.
   Т.е. если служба не самостоятельна, а является лишь зависимость для других служб, то секция не нужна.
1. Доступные цели: poweroff.target (runlevel0) — выключение, rescue.target (runlevel1) — rescue shell готов, multi-user.target (runlevel2, 3, 4) — пользователи могут логиниться и использовать CLI, graphical.target (runlevel5) — пользователи могут использовать графический режим, reboot.target (runlevel6) — перезагрузка.

### Монтирование с systemd

Пример mount-файла для тома Gluster:
```
[Unit]
Description=⟨description⟩
BindsTo=glusterd.service
After=glusterd.service

[Mount]
What=localhost:/⟨volume⟩
Where=⟨mount point⟩
Type=glusterfs
Options=defaults,_netdev
DirectoryMode=0755
```

Примечания:
1. Имя mount-файла должно соответствовать точке монтирования.
   Например, `/var/lockvol` — `var-lockvol.mount`.
1. Команда `systemctl start` монтирует, `systemctl stop` — отмонтирует.
1. `ExecStartPre` и ко недоступны.
1. При работе с Gluster может понадобиться обеспечить задержку для корректного монтирования.

# Переменные окружения

Вывести все переменные окружения:
```
$ printenv
```

Выполнить одну команду с нужными переменными окружения:
```
$ ⟨var1⟩=⟨value1⟩ ⟨var2⟩=⟨value2⟩ ⟨command⟩
```
Заданные переменные станут переменными окружения в порождённом процессе.
А в текущем процессе не станут, поэтому использовать их в качестве аргумента команды не выйдет.
Например, так не сработает, `echo` выведет пустую строку:
```
$ i=1 echo "$i"
```
Так сработает:
```
$ i=1 bash -c 'echo "$i"'
```

Локальные переменные (для текущей сессии) задаются и удаляются так:
```
$ export ⟨var⟩=⟨value⟩
$ unset ⟨var⟩
```

Переменные для конкретного пользователя лежат в
1. `~/.bashrc` — выполняется при старте нового процесса Bash пользователем, который уже находится в системе (non-login shell).
1. `~/.bash_profile` (или `~/.profile`) — выполняется при старте нового процесса Bash, когда пользователь входит по SSH (login shell).

Переменные для всех пользователей лежат в
1. `/etc/bash.bashrc` — то же, что и `~/.bashrc`, но для всех пользователей (только Debian и Ubuntu).
1. `/etc/profile` — то же, что и `~/.bash_profile`, но для пользователей.
1. `/etc/environment` — тут лежат общесистемные переменные окружения, это не скрипт.
   Чтобы изменения вступили в силу надо перелогиниться.

Получить значение переменной, а если переменной нет, то использовать значение по умолчанию:
```
$ echo ${⟨var⟩:-⟨default value⟩}
```

Создать alias можно, добавив строку в `~/.bashrc` или в `~/.bash_aliases` (если таковой подключается в `~/.bashrc`):
```
alias ⟨alias⟩=⟨command⟩
```
Пример:
```
alias grep='grep --color=auto'
```

# Криптография

Экспортировать публичный ключ в виде key-файла:
```
$ gpg --armor --output ⟨output key file⟩ --export ⟨id⟩
```

Расшифровать сообщение в формате ASN.1 DER:
```
$ openssl asn1parse -inform der -in ⟨file⟩
```

Вывести сертификаты в указанной БД:
```
$ certutil -L -d ~/.mozilla/firefox/*.default
```

Создать сертификат и ключи в виде PFX-файла (формат PKCS #12):
```
$ openssl genrsa -des3 -out myCA.key 2048
$ openssl req -x509 -new -nodes -key myCA.key -sha256 -days 1825 -out myCA.pem
$ openssl pkcs12 -inkey myCA.key -in myCA.pem -export -out myCA.pfx
```

Поучить билет Kerberos:
```
$ kinit -f ⟨user⟩
```

Вывести билеты Kerberos:
```
$ klist
```

### Пакет ldap-utils

Выполнить LDAP-запрос:
```
$ ldapsearch -H ldap://⟨host⟩ -LLL -Q -o ldif-wrap=no -b ⟨DN⟩ ⟨filter⟩
```
Примечания:
1. `-Q` — использовать SASL-аутентификацию + тихий режим.
   Работает, если есть активный билет Kerberos.
1. `-LLL` — вывести результат в формате LDIF без комментариев и версии.
1. `-S` — атрибут, по которому происходит сортировка.
   Пустая строка означает сортировку по DN.
1. `-s` — область поиска (scope): `base`, `one`, `sub` или `children`.

Получить доступные механизмы SASL-аутентификации:
```
$ ldapsearch -H ldap://⟨host⟩ -x -LLL -s base -b "" supportedSASLMechanisms
```

Добавить записи в службу каталогов:
```
$ ldapadd -Q -H ldap://⟨host⟩ -f ⟨LDIF file⟩
```

Удалить запись из службы каталогов:
```
$ ldapdelete -Q -H ldap://⟨host⟩ ⟨DN⟩
```
Примечания:
1. Может работать с LDIF-файлами как `ldapadd`.

# Deb-пакеты

Получить список установленных пакетов:
```
$ apt list --installed
```

Вывести список файлов установленного пакета:
```
$ dpkg -L ⟨package⟩
```

Вывести пакет, из которого появился файл:
```
$ dpkg -S ⟨path⟩
```

Вывести полное дерево зависимостей (нужен пакет `apt-rdepends`):
```
$ apt-rdepends ⟨package⟩
```

Пометить пакет как установленный вручную, дабы его не удалило:
```
# apt-mark manual ⟨package⟩
```

Обновиться на новый релиз:
```
# aptitude update
# aptitude full-upgrade
```

Удалить скачанные deb-пакеты (лежат в `/var/cache/apt/archives`):
```
# apt-get clean
```

Установить пакет из файла:
```
# dpkg -i ⟨deb file⟩
```
Примечания:
1. Осторожно! Оно не проверяет зависимости до начала установки.
1. `--force-all` для игнора проблем с зависимостями.
1. `--force-architecture` отключает проверку архитектуры.
1. Чтобы установить не в `/` (например, для кросс-компиляции): `--force-not-root --root=⟨path⟩`.

Распаковать deb-файл:
```
$ dpkg -x ⟨deb file⟩ ⟨target directory⟩
```

### Репозитории

Для подключения репозитория в `/etc/apt/sources.list` добавляется строка:
```
deb ⟨repo location⟩ ⟨distribution⟩ ⟨component1⟩ ⟨component2⟩ ⟨component3⟩...
```
Доступные дистрибутивы можно посмотреть в каталоге `⟨repo location⟩/dists`.


Добавить публичный ключ репозитория (нужен пакет `gnupg`):
```
$ wget -O- ⟨URL⟩ | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/⟨some name⟩.gpg
```

Для использования прокси добавляем в `/etc/apt/apt.conf`:
```
Acquire::http:Proxy "http://⟨host⟩:⟨port⟩";
```

### Сборка пакетов

Собрать пакеты из папки с исходниками (требуются пакеты `devscripts`, `build-essential`, `lintian`):
```
$ debuild --no-tgz-check -d -us -uc
```

Скачать из репозитория исходники и собрать пакет:
1. Скачать исходники пакета:
   ```
   $ apt-get source ⟨package⟩
   ```
1. Пропатчить что-то, если нужно.
1. ```
   $ apt-get -b source ⟨package⟩
   ```

### Патчинг c quilt

Применить/отменить все патчи:
```
$ quilt push -a
$ quilt pop -a
```

Создать патч:
1. ```
   $ quilt new ⟨patch name⟩
   ```
1. ```
   $ quilt add ⟨file⟩
   ```
   Можно вызвать несколько раз для разных файлов.
1. Правим файлы (НЕ в папке `.pc`).
1. ```
   $ quilt refresh
   ```

# RPM-пакеты

Скачать исходники пакета (файл `src.rpm`):
```
$ yumdownloader --source ⟨package⟩
```

Собрать RPM-пакеты из `src.rpm`:
```
$ rpmbuild --rebuild ⟨src.rpm file⟩
```
Собрать RPM-пакеты по `spec`-файлу:
```
$ rpmbuild -ba ⟨spec file⟩
```

Распаковать `rpm`-архив в текущий каталог:
```
$ rpm2cpio ⟨rpm file⟩ | cpio -idmv
```

Вывести список файлов, установленных пакетом (2 варианта):
```
$ rpm -ql ⟨package⟩
$ repoquery --list ⟨package⟩
```

Импортировать ключ репозитория:
```
$ rpm --import ⟨key file⟩
```

# Ядро, модули ядра

Вывести все загруженные модули ядра (нужен пакет `kmod`):
```
$ lsmod
```

Загрузить модуль ядра из произвольного места:
```
# insmod ⟨path⟩ ⟨options⟩
```
Не умеет подгружать нужные зависимости, лишь ругается, если они не удовлетворены.

Выгрузить модуль:
```
# rmmod ⟨module⟩
```

`modprobe` работает поверх низкоуровневых `insmod` и `rmmod`.
Загрузить модуль c зависимостями:
```
# modprobe ⟨module⟩ ⟨options⟩
```

Избавиться от дурацких пиков системного динамика:
```
# echo "blacklist pcspkr" | tee /etc/modprobe.d/nobeep.conf
```

### Сборка ядра

1. Создать `.config`:
   ```
   $ cp -v /boot/config-$(uname -r) .config
   ```
1. Настроить `.config`:
   ```
   $ make menuconfig
   ```
1. ```
   $ make
   ```
1. Установить модули ядра:
   ```
   # make modules_install
   ```
1. Установить ядро:
   ```
   # make install
   ```
1. Обновить Grub на Debian/Ubuntu:
   ```
   # update-initramfs -c -k ⟨version⟩
   # update-grub
   ```

# Разработка

`LD_LIBRARY_PATH` — это список каталогов, где система ищет библиотеки, прежде чем обратиться к стандартным каталогам, заданным в `/etc/ld.so.conf`.
Для Qt-приложений также есть `QT_PLUGIN_PATH`.

Зарегистрировать новую папку с динамическими библиотеками:
1. Добавить новый conf-файл в `/etc/ld.so.conf.d`.
1. ```
   # ldconfig
   ```

Получить названия пакетов для использования в `PKG_CHECK_MODULES`:
```
$ pkg-config --list-all
```
В переменной окружения `PKG_CONFIG_PATH` лежат доп. пути, где `pkg-config` будет искать пакеты.

Вывести все-все динамические библиотеки, нужные для запуска бинаря:
```
$ ldd ⟨binary file⟩
```

Вывести только прямые зависимости бинаря:
```
$ readelf -d ⟨binary file⟩
```

При помощи `--always-make` можно заставить `make` выполнить сборку, даже если он считает, что она не требуется.

### Autotools

Примерная последовательность действий (нужны пакеты `autoconf`, `automake`, `libtool`):
```
$ aclocal
$ autoheader
$ automake --add-missing
$ autoreconf -ivf
$ mkdir build && cd build
$ ../configure
$ make
```

Флаги кладутся в `CFLAGS`, `CXXFLAGS`, `LDFLAGS`.

Для кросс-компиляции:
1. Если компилятор нестандартный, то добавить в `PATH` путь к папке `bin`, в которой лежит компилятор.
1. При вызове `configure` указать параметры `--build=x86_64-linux-gnu`, `--host=mipsel-linux-gnu`.
1. Если нужно окружение, то задать `--sysroot=<path>` в `CFLAGS` и переменные окружения `PKG_CONFIG_LIBDIR` и `PKG_CONFIG_SYSROOT_DIR`.

### CMake

Собрать проект в отдельном каталоге:
```
$ mkdir build
$ cd build
$ cmake ..
$ cmake --build .
```
Примечание: в любой непонятной ситуации ставить пакет `extra-cmake-modules`.

Определить опцию (может быть только `ON` или `OFF`):
```
option(⟨variable⟩ "⟨help text⟩" ⟨default value⟩)
```
Если не указать значение по умолчанию, то будет `OFF`.

Определить переменную (Normal Variable):
```
set(⟨variable⟩ ⟨value⟩)
```

Определить Cache Entry:
```
set(⟨variable⟩ ⟨value⟩ CACHE ⟨type⟩ ⟨docstring⟩ [FORCE])
```
Примечания:
1. Если переменной с таким именем нет, то CMake лезет в кеш.
1. По умолчанию существующие значения не перезаписываются.
   `FORCE` в помощь.

Можно задать переменные и пр. в cmake-файле и указать на него при помощи `-DCMAKE_TOOLCHAIN_FILE=⟨path⟩`.

Флаги компилятора кладутся в `CMAKE_C_FLAGS`, `CMAKE_CXX_FLAGS`, `CMAKE_EXE_LINKER_FLAGS_INIT`, `CMAKE_SHARED_LINKER_FLAGS_INIT`, `CMAKE_MODULE_LINKER_FLAGS_INIT`.

Примерный набор параметров для кросс-компилиции:
- `CMAKE_SYSTEM_NAME`, например, Linux;
- `CMAKE_SYSTEM_PROCESSOR`, например, mipsel;
- `CMAKE_C_COMPILER` и/или `CMAKE_CXX_COMPILER`;
- `CMAKE_INSTALL_PREFIX`.

Если нужно окружение, то задать:
- `CMAKE_SYSROOT`;
- `CMAKE_FIND_ROOT_PATH_MODE_PROGRAM` = `NEVER`;
- `CMAKE_FIND_ROOT_PATH_MODE_LIBRARY` = `ONLY`;
- `CMAKE_FIND_ROOT_PATH_MODE_INCLUDE` = `ONLY`;
- `CMAKE_FIND_ROOT_PATH_MODE_PACKAGE` = `ONLY`.

Настройка генерации `config.h`:
```
#cmakedefine ENABLE_CPRO 1
```
Если переменная существует, то результатом будет `#define ENABLE_CPRO 1`.
См. также `#cmakedefine01`.

Запустить тесты:
```
$ ctest
```
Примечания:
1. Можно добавить переменную окружения `CTEST_OUTPUT_ON_FAILURE=1`.

### gdb

Некоторые варианты задания точек останова:
1. ```
   break ⟨file name⟩:⟨line number⟩
   ```
1. ```
   break ⟨file name⟩:⟨function⟩
   ```
1. ```
   break ⟨function⟩
   ```

Вывести список потоков:
```
info threads
```
Переключиться на поток №1:
```
thread 1
```

Отладка внешних процессов:
1. Подключиться к существующему процессу (при этом он останавливается):
   ```
   attach ⟨pid⟩
   ```
1. Продолжить выполнение процесса:
   ```
   cont
   ```
1. Освободить процесс (при этом он продолжит выполнение):
   ```
   detach
   ```

Значения параметра `follow-fork-mode`:
1. `parent` (по умолчанию) — при вызове `fork()` или `vfork()` GDB продолжит дебажить родительский процесс.
1. `child` — при вызове `fork()` или `vfork()` GDB переключится на дочерний процесс.

Значения параметра `detach-on-fork`:
1. `on` (по умолчанию) — GDB может дебажить только 1 процесс (либо родительский либо дочерний в зависимости от `follow-fork-mode`).
1. `off` — при вызове `fork()` или `vfork()` GDB будет дебажить и родительский и дочерний процесс.

Вывести значение параметра:
```
show ⟨param⟩
```

Установить значение параметра:
```
set ⟨param⟩ ⟨value⟩
```

# Скрипты на Bash

Шапка:
```
#!/bin/bash
```

`set -e` повелевает прервать выполнение скрипта, если какая-либо команда вернёт ошибку.

Завершить выполнение скрипта с заданным кодом:
```
exit ⟨code⟩
```

Передать все аргументы другому скрипту:
```
another_script.sh "$@"
```

### Функции

Функции ведут себя аналогично командам.
Объявление функции и её вызов:
```
function f() {
    echo "I am f()"
}
f
```

Функция получает аргументы, пишет в stdout и возвращает код:
```
function sum() {
    echo $(($1 + $2))
    return 33
}
output=$(sum 10 6)
rc=$?
echo "$rc $output"
```

### Блок if-elif-else-fi

Работа с числами:
```
var=11
if [ $var == 10 ]
then
    echo "var == 10"
elif [ $var == 11 ]
then
    echo "var == 11"
else
    echo "var != 10, var != 11"
fi
```
`-lt` — это `<`, `-le` — это `<=`, `-gt` — это `>`, `-ge` — это `>=`.

Проверить существует ли файл:
```
if [ -f /etc/resolv.conf ]
then
    echo "resolv.conf exists."
fi
```
Если надо проверить, что файла нет: `! -f /etc/resolv.conf`.

Проверить существует ли переменная:
```
if [ -v ololo ]
then
    echo "Variable ololo exists."
fi
```
Если надо проверить, что переменной нет: `! -v ololo`.

Проверка при помощи выполнения какой-либо команды:
```
if ⟨command⟩
then
    echo 'return code == 0'
else
    echo 'return code != 0'
fi
```

### Циклы

`while` со счетчиком:
```
count=0
while [ $count -lt 10 ]
do
    echo "$count"
    (( count++ ))
done
```

Обход файлов:
```
find . -maxdepth 1 -name "*" | while read f
do
    echo "$f"
done
```

`for` с массивом:
```
strings=(
    str0
    str1
    "str with spaces"
)
for i in "${strings[@]}"
do
    echo "$i"
done
```

`for` со строкой:
```
items="0 1 2 3 4 5"
for i in $items
do
    echo "$i"
done
```

`for` с диапазоном:
```
for i in {0..10}
do
    echo "$i"
done
```

Также доступны `break` и `continue`.

# Прочее

Перейти в предыдущую папку:
```
$ cd -
```

Мониторить вывод какой-то команды:
```
$ watch ⟨command⟩
```

Если команда выполнилась с ошибкой, то выполнить другую:
```
$ ⟨command 1⟩ || ⟨command 2⟩
```

Арифметическое выражение:
```
$ echo $((6+6))
```

Вывести код возврата последней команды:
```
$ echo $?
```

Вывести PID интерпретатора:
```
$ echo $$
```

Для мониторинга I/O есть `iftop` и `iotop`.

Выполнить команду и сохранить её вывод:
```
$ ⟨var⟩=`⟨command⟩`
```

Админка CUPS живёт на `http://localhost:631/`.

Установить KDE на голую систему:
1. ```
   # aptitude install task-kde-desktop
   ```
1. Перезагрузить.

Установить Gnome на голую систему:
1. ```
   # aptitude install task-gnome-desktop
   ```
1. Перезагрузить.

Для корректной работы Bluetooth-устройств, связанных с аудио, нужен `pulseaudio-module-bluetooth`:
1. ```
   # aptitude install pulseaudio-module-bluetooth
   ```
1. Перезапустить pulseaudio:
   ```
   $ pulseaudio -k
   $ pulseaudio --start
   ```

Вывести информацию о сертификате:
```
$ openssl x509 -in ⟨cert⟩ -dates
```

`xargs` берёт данные из stdin или из файла, разбивает их в соответствии с указанными параметрами и скармливает другой программе в качестве аргумента.
Удалить файлы по шаблону `*.sh`:
```
$ find . -name '*.sh' | xargs rm -f
```

Установить минимальный набор пакетов для работы с LaTeX:
```
# aptitude install texlive texlive-base texlive-lang-cyrillic texlive-latex-extra texlive-font-utils
```

### Контрольные суммы

MD5 строки:
```
$ echo -n ⟨string⟩ | md5sum
```
MD5 файла:
```
$ md5sum ⟨file⟩
```
`sha256sum`, `sha512sum` — аналогично.

Кодировать строку в base64:
```
$ echo ⟨string⟩ | base64
```
Декодировать из base64:
```
$ echo ⟨base64 string⟩ | base64 -d
```

Вывести CRC для файла:
```
$ cksum ⟨file⟩
```

### youtube-dl

`youtube-dl` из пакетов обычно бесполезен.
Надо ставить pipкой самый свежий:
```
# pip install youtube-dl
```

Скачать видео в 720p:
```
$ youtube-dl -f 'bestvideo[height=720][ext=mp4]+bestaudio[ext=m4a]' ⟨url⟩
```
Примечания:
1. `--write-auto-sub` для загрузки автоматически сгенерированных субтитров.
1. `--write-sub` для загрузки пользовательских субтитров.

Скачать аудио дорожку:
```
$ youtube-dl -x --audio-format mp3 ⟨url⟩
```

### Манипуляции с документами

Вывести инфу по изображению (нужен пакет `imagemagick`):
```
$ identify -verbose ⟨path⟩
```

Проверить целостность PNG-файла + вывести инфу по нему (нужен пакет `pngcheck`):
```
$ pngcheck ⟨PNG file⟩
```

Сгенерировать многостраничный TIF из нескольких JPG (нужен пакет `imagemagick`):
```
$ convert -compress jpeg -quality 50 ⟨directory⟩/*.jpg ⟨output TIF⟩
```

Сгенерировать PDF-файл без сжатия:
```
$ qpdf --qdf --object-streams=disable --stream-data=uncompress --generate-appearances ⟨input PDF⟩ ⟨output PDF⟩
```
